// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  define(['js/board-data'], function(Board) {
    return function(canvas) {
      var Circ, Line, color, getCoord, getStonePos, prop, renderStone, state, stoneColor, switchContext, tool, updateCurrentCoord, updateUI, updating, x, xint, y, yint, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      paper.setup(canvas);
      tool = new paper.Tool();
      updating = false;
      updateUI = function() {
        if (!updating) {
          updating = true;
          return setTimeout((function() {
            updating = false;
            return paper.view.draw();
          }), 0);
        }
      };
      state = {
        stonesOnBoard: Board(),
        placeHolder: {
          black: null,
          white: null
        },
        currentColor: 'black',
        currentCoord: null
      };
      updateCurrentCoord = function(coord) {
        if (Board.compareCoord(coord, state.currentCoord)) {
          return false;
        } else {
          state.currentCoord = coord;
          return true;
        }
      };
      Circ = function(x, y, radius, line, fill, width) {
        var circ;
        circ = new paper.Path.Circle(new paper.Point(x, y), radius);
        circ.radius = radius;
        circ.x = x;
        circ.y = y;
        if (line != null) {
          circ.strokeColor = line;
        }
        if (width != null) {
          circ.strokeWidth = width;
        }
        if (fill != null) {
          circ.fillColor = fill;
        }
        return circ;
      };
      Line = function(start, end) {
        var line;
        line = new paper.Path();
        line.strokeColor = 'black';
        line.add(new paper.Point(start));
        line.add(new paper.Point(end));
        return line;
      };
      xint = canvas.width / 19;
      yint = canvas.height / 19;
      for (x = _i = _ref = xint / 2, _ref1 = canvas.width; xint > 0 ? _i <= _ref1 : _i >= _ref1; x = _i += xint) {
        Line([x, yint / 2], [x, canvas.height - yint / 2]);
      }
      for (y = _j = _ref2 = yint / 2, _ref3 = canvas.width; yint > 0 ? _j <= _ref3 : _j >= _ref3; y = _j += yint) {
        Line([xint / 2, y], [canvas.height - xint / 2, y]);
      }
      for (x = _k = _ref4 = xint / 2 + xint * 3, _ref5 = canvas.width, _ref6 = xint * 6; _ref6 > 0 ? _k <= _ref5 : _k >= _ref5; x = _k += _ref6) {
        for (y = _l = _ref7 = yint / 2 + yint * 3, _ref8 = canvas.height, _ref9 = yint * 6; _ref9 > 0 ? _l <= _ref8 : _l >= _ref8; y = _l += _ref9) {
          Circ(x, y, 3, 'black', 'black');
        }
      }
      stoneColor = {
        black: new paper.Gradient([['gray', 0.0], ['black', 1]], 'radial'),
        white: new paper.Gradient([['gray', 0.0], ['white', 1]], 'radial')
      };
      getStonePos = function(coord) {
        var xPos, yPos;
        x = coord[0], y = coord[1];
        xPos = x * xint - xint / 2;
        yPos = y * yint - yint / 2;
        return [xPos, yPos];
      };
      getCoord = function(pos) {
        var snap;
        x = pos[0], y = pos[1];
        snap = function(pos, interval) {
          return Math.floor(pos / interval + 1);
        };
        return [snap(x, xint), snap(y, yint)];
      };
      renderStone = function(color, coord) {
        var gradCol, stone, xPos, yPos, _ref10;
        _ref10 = getStonePos(coord), xPos = _ref10[0], yPos = _ref10[1];
        gradCol = new paper.GradientColor(stoneColor[color], [xPos - xint * 0.5, yPos + yint * 0.5], [xPos, yPos]);
        return stone = Circ(xPos, yPos, xint / 2.4, null, gradCol);
      };
      this.onHover = function() {};
      this.hoverStone = function(coord) {
        return state.placeHolder[state.currentColor].position = getStonePos(coord);
      };
      this.onPlayerMove = function() {};
      this.addStone = function(color, coord, isMove) {
        var stone;
        if (isMove == null) {
          isMove = true;
        }
        stone = renderStone(color, coord);
        if (!Board.offBoard(coord)) {
          state.stonesOnBoard.set(coord, stone);
        }
        if (isMove) {
          switchContext();
        }
        return updateUI();
      };
      this.removeStone = function(coord) {
        state.stonesOnBoard.get(coord).remove();
        state.stonesOnBoard.set(coord, void 0);
        return updateUI();
      };
      switchContext = (function(_this) {
        return function() {
          _this.hoverStone([-1, -1]);
          return state.currentColor = Board.switchColor(state.currentColor);
        };
      })(this);
      for (color in state.placeHolder) {
        state.placeHolder[color] = renderStone(color, [-1, -1]);
      }
      tool.onMouseMove = (function(_this) {
        return function(event) {
          var coord;
          if (event.event.target === canvas) {
            coord = getCoord([event.event.offsetX, event.event.offsetY]);
            if (updateCurrentCoord(coord)) {
              return _this.onHover(state.currentColor, coord);
            }
          } else {
            if (updateCurrentCoord([-1, -1])) {
              return _this.hoverStone([-1, -1]);
            }
          }
        };
      })(this);
      tool.onMouseDown = (function(_this) {
        return function(event) {
          var coord;
          coord = getCoord([event.event.offsetX, event.event.offsetY]);
          return _this.onPlayerMove(state.currentColor, coord);
        };
      })(this);
      updateUI();
      for (prop in this) {
        if (!__hasProp.call(this, prop)) continue;
        this[prop] = this[prop].bind(this);
      }
      return this;
    };
  });

}).call(this);
