// Generated by CoffeeScript 1.3.1
(function() {
  var Circ, GoBoard, Line,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Object.extend();

  Circ = function(x, y, radius, line, fill, width) {
    var circ;
    circ = new paper.Path.Circle(new paper.Point(x, y), radius);
    circ.radius = radius;
    circ.x = x;
    circ.y = y;
    if (line != null) {
      circ.strokeColor = line;
    }
    if (width != null) {
      circ.strokeWidth = width;
    }
    if (fill != null) {
      circ.fillColor = fill;
    }
    return circ;
  };

  Line = function(start, end) {
    var line;
    line = new paper.Path();
    line.strokeColor = 'black';
    line.add(new paper.Point(start));
    line.add(new paper.Point(end));
    return line;
  };

  GoBoard = function(canvas) {
    var bGrad, blackStone, board, gb, getPos, groups, history, neighbors, prisoners, valid, whiteStone, x, xint, y, yGrad, yint, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    xint = canvas.width / 19;
    yint = canvas.height / 19;
    for (x = _i = _ref = xint / 2, _ref1 = canvas.width; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _i += xint) {
      Line([x, yint / 2], [x, canvas.height - yint / 2]);
    }
    for (y = _j = _ref2 = yint / 2, _ref3 = canvas.width; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _j += yint) {
      Line([xint / 2, y], [canvas.height - xint / 2, y]);
    }
    for (x = _k = _ref4 = xint / 2 + xint * 3, _ref5 = canvas.width, _ref6 = xint * 6; _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; x = _k += _ref6) {
      for (y = _l = _ref7 = yint / 2 + yint * 3, _ref8 = canvas.height, _ref9 = yint * 6; _ref7 <= _ref8 ? _l <= _ref8 : _l >= _ref8; y = _l += _ref9) {
        Circ(x, y, 3, 'black', 'black');
      }
    }
    bGrad = new paper.Gradient([['gray', 0.0], ['black', 1]], 'radial');
    yGrad = new paper.Gradient([['gray', 0.0], ['white', 1]], 'radial');
    getPos = function(coords) {
      var xPos, yPos;
      x = coords[0], y = coords[1];
      xPos = x * xint - xint / 2;
      yPos = y * yint - yint / 2;
      return [xPos, yPos];
    };
    whiteStone = function(x, y) {
      var gradCol, xPos, yPos, _ref10;
      _ref10 = getPos([x, y]), xPos = _ref10[0], yPos = _ref10[1];
      gradCol = new paper.GradientColor(yGrad, [xPos - xint * 0.5, yPos + yint * 0.5], [xPos, yPos]);
      return Circ(xPos, yPos, xint / 2.4, null, gradCol);
    };
    blackStone = function(x, y) {
      var gradCol, xPos, yPos, _ref10;
      _ref10 = getPos([x, y]), xPos = _ref10[0], yPos = _ref10[1];
      gradCol = new paper.GradientColor(bGrad, [xPos + xint * 0.5, yPos - yint * 0.5], [xPos, yPos]);
      return Circ(xPos, yPos, xint / 2.4, null, gradCol);
    };
    groups = [];
    history = [];
    board = (function() {
      var _m, _results;
      _results = [];
      for (x = _m = 0; _m <= 18; x = ++_m) {
        _results.push([]);
      }
      return _results;
    })();
    board.get = function(coord) {
      if (coord == null) {
        coord = [];
      }
      x = coord[0], y = coord[1];
      if (board[x] != null) {
        return board[x][y];
      } else {

      }
    };
    board.remove = function(coord) {
      x = coord[0], y = coord[1];
      (this.get(coord)).graphic.remove();
      return delete board[x][y];
    };
    valid = function(pos, shouldBeEmpty) {
      var offBoard;
      if (shouldBeEmpty == null) {
        shouldBeEmpty = true;
      }
      offBoard = function(n) {
        return __indexOf.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], n) < 0;
      };
      if (offBoard(pos[0]) || offBoard(pos[1])) {
        return false;
      }
      return shouldBeEmpty === !((board.get(pos)) != null);
    };
    neighbors = function(pos, empty) {
      var nbs, _len, _m, _ref10;
      if (empty == null) {
        empty = true;
      }
      nbs = [];
      x = pos[0], y = pos[1];
      _ref10 = [[x, y - 1], [x + 1, y], [x, y + 1], [x - 1, y]];
      for (_m = 0, _len = _ref10.length; _m < _len; _m++) {
        pos = _ref10[_m];
        if (valid(pos, empty)) {
          nbs.push((empty ? pos : board.get(pos)));
        }
      }
      return nbs;
    };
    prisoners = {
      white: 0,
      black: 0
    };
    return gb = {
      history: history,
      whiteStone: whiteStone,
      blackStone: blackStone,
      prisoners: prisoners,
      getPos: getPos,
      findIntersection: function(coords) {
        var snap;
        x = coords[0], y = coords[1];
        snap = function(coord, interval) {
          return Math.floor(coord / interval + 1);
        };
        return [snap(x, xint), snap(y, yint)];
      },
      nextMove: {
        suicide: function() {
          var neighbor, _len, _len1, _m, _n, _ref10, _ref11;
          _ref10 = neighbors(this.position, true);
          for (_m = 0, _len = _ref10.length; _m < _len; _m++) {
            neighbor = _ref10[_m];
            return false;
          }
          _ref11 = neighbors(this.position, false);
          for (_n = 0, _len1 = _ref11.length; _n < _len1; _n++) {
            neighbor = _ref11[_n];
            if (neighbor.color === this.color) {
              if (groups[neighbor.groupNum].liberties() > 1) {
                return false;
              }
            } else {
              if (groups[neighbor.groupNum].liberties() === 1) {
                return false;
              }
            }
          }
          return true;
        },
        playable: function() {
          var last;
          if (!valid(this.position)) {
            return false;
          }
          if (this.suicide()) {
            return false;
          }
          if (history.length > 0) {
            last = history[history.length - 1];
            if (last.ko && last.ko[0] === this.position[0] && last.ko[1] === this.position[1]) {
              return false;
            }
          }
          return true;
        },
        graphic: blackStone(-1, -1),
        position: null,
        color: 'black',
        hover: function(pos) {
          this.position = gb.findIntersection(pos);
          if (!this.playable()) {
            this.position = [-1, -1];
          }
          return this.graphic.position = gb.getPos(this.position);
        },
        place: function() {
          var foe, group, n, neighbor, ng, ngNum, record, status, _len, _len1, _m, _n, _ref10, _ref11;
          if (this.playable()) {
            _ref10 = this.position, x = _ref10[0], y = _ref10[1];
            board[x][y] = {
              color: this.color,
              groupNum: groups.length,
              graphic: this.graphic
            };
            record = {
              color: this.color,
              x: x,
              y: y
            };
            group = [this.position];
            group.color = this.color;
            group.num = groups.length;
            group.liberties = function() {
              var liberties, stone, _len, _m;
              liberties = [];
              for (_m = 0, _len = this.length; _m < _len; _m++) {
                stone = this[_m];
                liberties = liberties.union(neighbors(stone));
              }
              return liberties.length;
            };
            group.test = function() {
              var stone, _len, _m;
              if (this.liberties() === 0) {
                for (_m = 0, _len = this.length; _m < _len; _m++) {
                  stone = this[_m];
                  board.remove(stone);
                }
                prisoners[this.color] += this.length;
                delete groups[group.num];
                return false;
              } else {
                return true;
              }
            };
            _ref11 = neighbors(this.position, false);
            for (_m = 0, _len = _ref11.length; _m < _len; _m++) {
              neighbor = _ref11[_m];
              if (neighbor.color === this.color) {
                ngNum = neighbor.groupNum;
                if (group.num !== ngNum) {
                  ng = groups[ngNum];
                  for (_n = 0, _len1 = ng.length; _n < _len1; _n++) {
                    n = ng[_n];
                    board.get(n).groupNum = groups.length;
                  }
                  group.push.apply(group, ng);
                  status = delete groups[ngNum];
                }
              } else {
                foe = groups[neighbor.groupNum];
                if (foe.test() === false) {
                  record.kills = foe;
                  if (foe.length === 1) {
                    record.ko = foe[0];
                  }
                }
              }
            }
            groups.push(group);
            group.test();
            history.push(record);
            if (this.color === 'white') {
              this.color = 'black';
              this.graphic = blackStone(-1, -1);
            } else {
              this.color = 'white';
              this.graphic = whiteStone(-1, -1);
            }
            return this;
          }
        }
      }
    };
  };

  window.onload = function() {
    var canvas, gb, tool;
    canvas = document.getElementById("goban");
    paper.setup(canvas);
    gb = GoBoard(canvas);
    tool = new paper.Tool();
    tool.onMouseMove = function(event) {
      if (event.event.target === canvas) {
        return gb.nextMove.hover([event.event.offsetX, event.event.offsetY]);
      } else {
        return gb.nextMove.hover(gb.getPos([-1, -1]));
      }
    };
    tool.onMouseDown = function(event) {
      return gb.nextMove.place();
    };
    return paper.view.draw();
  };

}).call(this);
